(* PARCOURS EN LARGEUR *)

(* Avec une file implémentée par un vecteur "flottant" : les indices t et q pointent respectivement sur la tête (sauf si la liste est vide) et la première case libre de la file *)
(* La méthode fonctionne ici car on sait que l'on va insérer au maximum n éléments dans la file *)

type file = {table: int vect; mutable t: int; mutable q: int};;

let creer_file_vide(n) = {table=make_vect n 0;t=0;q=0} ;;

let est_vide f = (f.t=f.q);;    (* dès que la file est vide, on réinitialise les champs t et q à la valeur 0 *)

let inserer a f = match f.q with
     |j when j=vect_length f.table -> failwith "La file est pleine"
     |j -> f.table.(j) <- a; f.q<-j+1;;



let defiler f = match est_vide f with
     true -> failwith "file vide"
     | _ ->  let i=f.t in
             f.t <- i+1;
             f.table.(i);;

let f=creer_file_vide(10);;
inserer 1 f;inserer 2 f; inserer 3 f; defiler f;;
inserer 4 f; defiler f;;
defiler f;;
f;;
defiler f;;
defiler f;;

let plus_courts_chemin G s = 
	let d= make_vect (vect_length G) (-1) in
	let pi= make_vect (vect_length G) (-1) in
	let F = creer_file_vide(vect_length G) in
	   inserer s F;
	   d.(s) <- 0;
	   while not(est_vide(F)) do
	      let i = defiler F in
	      let l = ref G.(i) in
	         while (!l) <> [] do
	            let j = hd(!l) in
	               l := tl(!l);
	               if d.(j)=(-1) then
	                  begin
	                  d.(j) <- d.(i)+1;
	                  pi.(j)<-i;
	                  inserer j F
	                  end;
	         done;
	   done;
	   d,pi;;
   

let G = [|[5];[0;2];[];[1];[2;3;6];[];[3;5;9];[4;6];[5;9];[8]|] ;;

plus_courts_chemin G 4 ;;


(* Avec une file implémentée à l'aide de listes doublement chainée *)

type 'a ldc = Vide | Cellule of 'a cell 
       and 'a cell = {mutable avant: 'a ldc; mutable valeur: 'a; mutable apres: 'a ldc} ;;

type 'a file = {mutable tete: 'a ldc; mutable queue : 'a ldc} ;;

let cell = function
  Vide -> failwith "la liste est vide"
  |Cellule(c) -> c;;

let creer_file_vide () = {tete=Vide;queue=Vide} ;;


let est_vide f = (f.tete=Vide);;

let inserer a f = match est_vide f with
     true -> let L=Cellule {avant=Vide;valeur=a;apres=Vide} in
                 f.tete<-L;
                 f.queue<-L
     | _ -> let L1 = f.queue in let L = Cellule {avant=L1;valeur=a;apres=Vide} in
            (cell L1).apres <- L;
            f.queue <- L;;        


let defiler f = match est_vide f with
     true -> failwith "file vide"
     | _ ->   let C = cell(f.tete) in
                 match C.apres with
                 Vide -> f.tete <-Vide;
                             f.queue <-Vide;
                             C.valeur
                 | g ->    f.tete <- g;
                             (cell g).avant<-Vide;
                             C.valeur;;


let plus_courts_chemin G s = 
	let d= make_vect (vect_length G) (-1) in
	let pi= make_vect (vect_length G) (-1) in
	let F = creer_file_vide() in
	   inserer s F;
	   d.(s) <- 0;
	   while not(est_vide(F)) do
	      let i = defiler F in
	      let l = ref G.(i) in
	         while (!l) <> [] do
	            let j = hd(!l) in
	               l := tl(!l);
	               if d.(j)=(-1) then
	                  begin
	                  d.(j) <- d.(i)+1;
	                  pi.(j)<-i;
	                  inserer j F
	                  end;
	         done;
	   done;
	   d,pi;;
   

let G = [|[5];[0;2];[];[1];[2;3;6];[];[3;5;9];[4;6];[5;9];[8]|] ;;

plus_courts_chemin G 4 ;;


(* La même chose sans file : à chaque étape, la pile L contient les sommets qui sont à la distance k de s et on calcule la pile newL des sommets qui sont à la distance k+1 de s *)


let plus_courts_chemin G s = 
   let d= make_vect (vect_length G) (-1) in
   let pi= make_vect (vect_length G) (-1) in 
   let L = ref [s] and k = ref 0 in    (* s est le seul sommet à la distance 0 de s *)
   d.(s) <- 0; 
   while (!L) <> [] do
	    incr k;                         (* on incrémente k *)  
	    let newL = ref [] in 
	    while(!L) <> [] do                (* tant que la pile L est non vide *)  
	       let i=hd(!L) in              (* on retire l'élément i qui est en tête de L *) 
	       L := tl(!L); 
	       let fils = ref G.(i) in      (* on parcourt la liste de ses successeurs *)
	       while(!fils) <> [] do        
            let j=hd(!fils) in 
            fils := tl(!fils);      
            if d.(j)=(-1) then        (* pour chaque successeur j de i qui n'a pas été rencontré *)
               begin                  
               d.(j) <- (!k);         (* j est à la distance k de s *)   
               pi.(j)<-i;             (* le père de j sera i dans l'arborescence finale *)   
               newL := j::(!newL)     (* on ajoute j à la "nouvelle pile" *)
               end;
         done; 
      done;
      L :=!newL;                      (* on fait pointer L vers la nouvelle pile *)
   done;
   d,pi;;

plus_courts_chemin G 4 ;;
